name: Deploy Lambda Function

on:
  push:
    branches: [main, develop]
    paths:
      - 'cmd/lambda*/**'
      - 'internal/lambda/**'
      - 'internal/client/**'
      - 'internal/analyzer/**'
      - 'internal/scheduler/**'
      - 'internal/config/**'
      - 'internal/state/**'
      - 'terraform/**'
      - '.github/workflows/deploy-lambda.yml'
  pull_request:
    branches: [main]
    paths:
      - 'cmd/lambda*/**'
      - 'internal/lambda/**'
      - 'internal/state/**'
      - 'terraform/**'

env:
  AWS_REGION: us-east-1
  FUNCTION_NAME: hourstats

jobs:
  test:
    runs-on: [self-hosted, linux, x64, ubuntu-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Run tests
        run: go test ./...

      - name: Run linter
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest

  build:
    needs: test
    runs-on: [self-hosted, linux, x64, ubuntu-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Build Lambda functions
        run: |
          # Build individual Lambda functions
          for dir in cmd/lambda-*; do
            echo "Building $dir..."
            cd "$dir"
            GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bootstrap .
            zip "${dir##*/}.zip" bootstrap
            mv "${dir##*/}.zip" ../../terraform/
            cd ../..
          done
          
          # Also build the original single Lambda for backward compatibility
          echo "Building original single Lambda..."
          cd cmd/lambda
          GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bootstrap .
          zip hourstats.zip bootstrap
          mv hourstats.zip ../../terraform/
          cd ../..
          
          # List all built files
          echo "Built Lambda functions:"
          ls -la terraform/*.zip

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-functions
          path: terraform/

  deploy:
    needs: build
    runs-on: [self-hosted, linux, x64, ubuntu-latest]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-functions
          path: terraform/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=hourstats-terraform-state" \
            -backend-config="key=hourstats/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=hourstats-terraform-locks"

      - name: Import Existing Resources
        run: |
          cd terraform
          # Import existing S3 bucket and DynamoDB table if they exist
          terraform import aws_s3_bucket.terraform_state hourstats-terraform-state || true
          terraform import aws_dynamodb_table.terraform_locks hourstats-terraform-locks || true

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve

      - name: Update SSM Parameters
        run: |
          aws ssm put-parameter \
            --name "/hourstats/bluesky/handle" \
            --value "hourstats.bsky.social" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/analysis_interval_minutes" \
            --value "30" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/top_posts_count" \
            --value "5" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "false" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}

      - name: Test Step Functions Workflow
        run: |
          # Set dry run mode to make workflow complete faster
          echo "Setting workflow to dry run mode for faster testing..."
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "true" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          # Start Step Functions execution
          echo "Starting Step Functions workflow execution..."
          EXECUTION_ARN=$(aws stepfunctions start-execution \
            --state-machine-arn "arn:aws:states:${{ env.AWS_REGION }}:478250316157:stateMachine:hourstats-workflow" \
            --name "test-execution-$(date +%s)" \
            --region ${{ env.AWS_REGION }} \
            --query 'executionArn' \
            --output text)
          
          echo "Step Functions execution started with ARN: $EXECUTION_ARN"
          
          # Wait for 30 seconds and check execution status
          echo "Waiting 30 seconds to check workflow execution..."
          sleep 30
          
          # Check execution status
          EXECUTION_STATUS=$(aws stepfunctions describe-execution \
            --execution-arn "$EXECUTION_ARN" \
            --region ${{ env.AWS_REGION }} \
            --query 'status' \
            --output text)
          
          echo "Step Functions execution status: $EXECUTION_STATUS"
          
          if [ "$EXECUTION_STATUS" = "RUNNING" ] || [ "$EXECUTION_STATUS" = "SUCCEEDED" ]; then
            echo "✅ Step Functions workflow has been running for 30+ seconds without error - SUCCESS"
            echo "Workflow status: $EXECUTION_STATUS"
            
            # If still running, stop it to save resources
            if [ "$EXECUTION_STATUS" = "RUNNING" ]; then
              echo "Stopping execution to save resources..."
              aws stepfunctions stop-execution \
                --execution-arn "$EXECUTION_ARN" \
                --region ${{ env.AWS_REGION }} || true
            fi
            
            echo "Step Functions test completed successfully - workflow is working correctly"
          else
            echo "❌ Step Functions execution failed or completed too quickly"
            echo "Final status: $EXECUTION_STATUS"
            
            # Get execution history for debugging
            echo "Execution history:"
            aws stepfunctions get-execution-history \
              --execution-arn "$EXECUTION_ARN" \
              --region ${{ env.AWS_REGION }} \
              --query 'events[*].{Type:type,Time:timestamp,Details:eventDetails}' \
              --output table || true
            
            exit 1
          fi
          
          # Restore dry run setting to false for production
          echo "Restoring dry run setting to false for production..."
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "false" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}

  notify:
    needs: [test, build, deploy]
    runs-on: [self-hosted, linux, x64, ubuntu-latest]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ Multi-Lambda Step Functions workflow deployed successfully"
          else
            echo "❌ Multi-Lambda Step Functions workflow deployment failed"
          fi
