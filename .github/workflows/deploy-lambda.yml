name: Deploy Lambda Function

on:
  push:
    branches: [main, develop]
    paths:
      - 'cmd/lambda*/**'
      - 'internal/lambda/**'
      - 'internal/client/**'
      - 'internal/analyzer/**'
      - 'internal/scheduler/**'
      - 'internal/config/**'
      - 'internal/state/**'
      - 'terraform/**'
      - '.github/workflows/deploy-lambda.yml'
  pull_request:
    branches: [main]
    paths:
      - 'cmd/lambda*/**'
      - 'internal/lambda/**'
      - 'internal/state/**'
      - 'terraform/**'

env:
  AWS_REGION: us-east-1
  FUNCTION_NAME: hourstats

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Run tests
        run: go test ./...

      - name: Run linter
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Build Lambda functions
        run: |
          # Build individual Lambda functions
          for dir in cmd/lambda-*; do
            echo "Building $dir..."
            cd "$dir"
            GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bootstrap .
            zip "${dir##*/}.zip" bootstrap
            mv "${dir##*/}.zip" ../../terraform/
            cd ../..
          done
          
          # Also build the original single Lambda for backward compatibility
          echo "Building original single Lambda..."
          cd cmd/lambda
          GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bootstrap .
          zip hourstats.zip bootstrap
          mv hourstats.zip ../../terraform/
          cd ../..
          
          # List all built files
          echo "Built Lambda functions:"
          ls -la terraform/*.zip

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-functions
          path: terraform/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-functions
          path: terraform/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=hourstats-terraform-state" \
            -backend-config="key=hourstats/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=hourstats-terraform-locks"

      - name: Import Existing Resources
        run: |
          cd terraform
          # Import existing S3 bucket and DynamoDB table if they exist
          terraform import aws_s3_bucket.terraform_state hourstats-terraform-state || true
          terraform import aws_dynamodb_table.terraform_locks hourstats-terraform-locks || true

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve

      - name: Update SSM Parameters
        run: |
          aws ssm put-parameter \
            --name "/hourstats/bluesky/handle" \
            --value "hourstats.bsky.social" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/analysis_interval_minutes" \
            --value "60" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/top_posts_count" \
            --value "5" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "false" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}

      - name: Test Lambda Functions (Dry Run)
        run: |
          # Set dry run mode and limit posts for testing
          echo "Setting up test parameters..."
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "true" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          aws ssm put-parameter \
            --name "/hourstats/settings/max_posts" \
            --value "300" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}
          
          # Test orchestrator Lambda directly
          echo "Testing orchestrator Lambda function (dry run mode)..."
          aws lambda invoke \
            --function-name "hourstats-orchestrator" \
            --region ${{ env.AWS_REGION }} \
            --payload '{"analysisIntervalMinutes": 60}' \
            --cli-read-timeout 300 \
            /tmp/orchestrator-response.json
          
          echo "Orchestrator Lambda response:"
          cat /tmp/orchestrator-response.json
          
          # Check if the response indicates success
          if grep -q '"statusCode":200' /tmp/orchestrator-response.json; then
            echo "‚úÖ Orchestrator Lambda executed successfully"
            
            # Wait a moment for the fetcher chain to complete
            echo "Waiting for fetcher chain to complete..."
            sleep 30
            
            # Get the latest run to see what post would have been made
            echo "Checking what post would have been made..."
            RUN_ID=$(aws dynamodb scan \
              --table-name "hourstats-state" \
              --filter-expression "postId = :postId" \
              --expression-attribute-values '{":postId": {"S": "orchestrator"}}' \
              --projection-expression "runId" \
              --max-items 1 \
              --region ${{ env.AWS_REGION }} \
              --query 'Items[0].runId.S' \
              --output text)
            
            if [ "$RUN_ID" != "None" ] && [ -n "$RUN_ID" ]; then
              echo "Latest run ID: $RUN_ID"
              
              # Get the run details
              aws dynamodb get-item \
                --table-name "hourstats-state" \
                --key "{\"runId\": {\"S\": \"$RUN_ID\"}, \"postId\": {\"S\": \"orchestrator\"}}" \
                --region ${{ env.AWS_REGION }} \
                --query 'Item' > /tmp/run-details.json
              
              echo "Run details:"
              cat /tmp/run-details.json
              
              # Check if there's a formatted post
              POST_CONTENT=$(aws dynamodb get-item \
                --table-name "hourstats-state" \
                --key "{\"runId\": {\"S\": \"$RUN_ID\"}, \"postId\": {\"S\": \"orchestrator\"}}" \
                --region ${{ env.AWS_REGION }} \
                --query 'Item.formattedPost.S' \
                --output text)
              
              if [ "$POST_CONTENT" != "None" ] && [ -n "$POST_CONTENT" ]; then
                echo ""
                echo "üìù POST THAT WOULD HAVE BEEN MADE:"
                echo "=================================="
                echo "$POST_CONTENT"
                echo "=================================="
                echo "Character count: $(echo "$POST_CONTENT" | wc -c)"
                echo "Characters remaining: $((300 - $(echo "$POST_CONTENT" | wc -c)))"
                echo ""
              else
                echo "No formatted post found in run details"
              fi
            else
              echo "No runs found in database"
            fi
          else
            echo "‚ùå Orchestrator Lambda execution failed"
            exit 1
          fi
          
          # Restore dry run setting to false for production
          echo "Restoring dry run setting to false for production..."
          aws ssm put-parameter \
            --name "/hourstats/settings/dry_run" \
            --value "false" \
            --type "String" \
            --overwrite \
            --region ${{ env.AWS_REGION }}

  notify:
    needs: [test, build, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Multi-Lambda EventBridge workflow deployed successfully"
          else
            echo "‚ùå Multi-Lambda EventBridge workflow deployment failed"
          fi
